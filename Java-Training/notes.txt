Workflow of java code => Code -> compiler -> byte code -> JVM(JIT + Interpreter) -> binary code
Java is a high level language which is easily readable, understandable and instructable by programmer.
It is platform independent, because in java source code is converted into byte code which is easily executable in any platform which has JVM.
JVM - JVM stands for java virtual machine. It does not exists physically. It is used to convert byte code into binary code. It consists of JIT and Interpreter.
JRE - JRE stands for java runtime environment. It exists physically. It is used to provide environment to run the java program.
JDK - JDK stands for java development kit. It exists physically. It provides an environment to run as well as to develop a java program.

# Printing statements
System.out.print(); -> After printing the data the cursor is shifted to next position in same line.
System.out.println(); -> After printing the data the cursor is shifted to next position in new line.

# TOKENS:- The smallest part of java program
Types:-
1. Keywords:- Words with predefined meaning. (50+ keywords)
              It is also known as compiler aware words. 
              They should always be in lowercase. 
              In java we have 50+ keywords(eg:- class, public, static, void).

2. Identifier:- The name given by programmer. (cannot use keyword or character space, should not start with number, special characters are not allowed except _ and $) (eg:- class name, variable name, method names, package name)

3. Literals:- The value or data given by programmer.
Types:-
1.Number:- Integer and Floating number.

2.Character:- It is used to represent a single data. 
              It is enclosed inside single quotes.
              Length of character literal is one. 
              It can have lowercase, uppercase, single digits, all type of special characters.

3.String: - It is used to represent group of characters. 
            It is enclosed inside double quotes. 
            The length of string literal can br anything

4.Boolean - It gives us only 2 values, either true or false.

4.Separators:- To Separate java members.
Types:- 
{} - to separate block
() - separate equations, method declaration, write conditions
; - end of statement
, - separate variables
. - separate reference

5.Operators:- Symbol which represents particular operations
Types:-
1.Uniary:- 1.increment operator -> 1. Pre-increment 2. Post-increment
           2.decrement operator -> 1. Pre-decrement 2. Post-decrement
           3.logical not operator

2.Binary:- 1.Arithmetic operator
           2.Relational operator
           3.Logical AND operator
           4.Logical OR operator

3.Ternary:- Conditional operator

# DataTypes:- What type of data we are storing inside any variable
1. Primitive:- Inbuilt datatype, have fixed size. (byte,short,int,long | float,double | char | boolean)
2. Non-Primitive:- Does not have fixed size. (string,classname,arrays)

# Types of variables:-
1. Based on datatype:- 1. Primitive
                       2. Non- Primitive

2. Based on scope:- 1. Local variable(declared in local block or method block)
                    2. Global variable(declared in class block or global)

static variable:- A varivable which is declared inside class or global area prefixed with static keyword.
non static variable: - A varible which is declared inside class or global area without static keyword.

local varibable:- A variable which is declared inside local block. 
                  We cannot use local variables without initialisation. 
                  Local variables are not assigned with default values.
                  We cannot create two local variables with same name.
                  local varible can be used only inside same local block.

Gloal variables: - We can use global variables inside global as well as local area.

pre-increment operator steps:- 1.Increase the value by 1.
                               2.Update the incremented value in same variable.
                               3.If any operation is going on, will have to use the incremented value.

# Question
Q. Difference b/w primitive and non primitive data types?
-> Primitive data type has fixed size, they are pre defined. 
-> Non-primitive does not have fixed value and they are user defined.


Q. Difference b/w local and global variable?
-> local varibables can only be declared in local area. It cannot be used without initialisation. It can only be used in local area. We cannot create two local variables with same name.
-> Global varivables are declared in global area. It can be used inside gloabal as well as local area.


Q. Difference b/w compiler and Interpreter?
-> Compiler translates the high level code into machine code(byte code) before execution.
-> Interpreter translates and executes the code line by line at runtime.

Q. Difference b/w platform independent and platform dependent?
-> Platform-dependent software runs only on specific operating systems/hardware (like C/C++ compiled to native code)
-> Platform-independent software runs anywhere via an intermediary like a Virtual Machine (JVM for Java), allowing "write once, run anywhere" for Java, Python, etc.

Q. How does object oriented nature of java helps in software development?
-> Object-oriented programming (OOP) in Java accelerates software development by promoting code reusability through inheritance and composition, allowing new classes to inherit features from existing ones.

Q. Why java is considered simple language compared to c or c++?
-> Java is considered simpler than C or C++ due to a variety of design choices that reduce complexity for the programmer, such as automatic memory management (garbage collection), fewer language features, and a stronger emphasis on object-oriented programming.

Q. How does java provide security at runtime?
-> Java provides security at runtime through a multi-layered architecture centered around the Java Virtual Machine (JVM), which includes bytecode verification, a security sandbox, and extensive security APIs.

Q. What makes java as robust language?
-> Java is considered a robust language due to features that emphasize early error detection, effective error management, and reliable memory handling.

Q. How does java acheive high performance?
-> Through the Just-In-Time (JIT) compilation process and the sophisticated optimizations within the Java Virtual Machine (JVM).

Q. What do you mean by portability in java?
-> In Java, portability refers to the ability to compile a program's source code into a machine-independent bytecode on one machine and then run that same bytecode on any other device or operating system that has a compatible Java Virtual Machine (JVM) installed, without needing to recompile the code.

# Arithmetic Operators
(Addititon)
byte + byte -> CTE
short + short -> CTE
int + int -> success
long + long -> success
float + float -> success
double + double -> success
char + char -> CTE
string + string -> concat

# Typecasting
1. Primitive (Not Recommended)
    Types:- 1.Widening(Implicitly done by the compiler);
            2.Narrowing(Explicit);

2. Non - Primitive (Highly Recommended)

# Widening(implicit)
byte < short OR char < int < long < float < double (float is greater than long)
value to char is not possible, but char to value is possible

# Narrowing(Explicit)
double > float > long > int > short OR char > byte 

eg:- int i = 150;
     byte b = (byte) i;  '(range of byte is  -128 to 127 means total 256)
     byte value = int value âˆ’ 256  (if int > 127)


# Scanner class
steps:- 1. import java.util.Scanner;
        2. Declare Scanner class object (We can declare it in class block as well as method block)

        Scanner obj_ref_name = new Scanner(System.in)

-> If you are taking int input and then string input(obj.nextLine()) you have to create a dummy. Also when we use next() and then nextLine() we have to create a dummy;
e.g:- 1. a = obj.nextInt();
         obj.nextLine();
         b = obj.nextLine();  //group of words

      2. a = obj.next();   //single word
         obj.nextLine();
         b = obj.nextLine();

-> To stop resource leak we have to close the object with obj.close().

# Control statements
1. Decision making:- 1. if
                     2. if else
                     3. if else ladder
                     4. switch // boolean,float,double and long cannot be used in switch case value or key value as per IT convention;
                     5. nested if

2. Looping:-  1. for loop  // entry check loop
              2. while loop   // entry check loop
              3. do while loop :- Even the condition is false it will execute one time   //exit check loop
              4. for each loop
              5. nested loop

3. Jumping:- 1. break
             2. continue
             3. return

# Main attributes of software Engg.
1. Maintainability
2. Portability
3. Scalability
4. Security

#Loops
when the condition is <= , < -> increment(going forward)
when the condition is >= , > -> decrement(going backward)

#methods
-> block of memory
syntax:- [Access modifier] [modifier] return type method name (formal args)
         Access modifier, modifier and formal args are not mandatory

Method Terminology:- 1. Method signature:- method name along with formal arguments
                     2. Method declaration: - access modifier and modifier
                     3. Method definition

Method Definition:- 1.Method declaration
                    2.Method block(Implementation/Body)

Access Modifiers:- 1.private:- Access within class
                   2.public:- can be accessed from anywhere(within class, package to package)
                   3.protected:- direct approach is not possible, use inheritance
                   4.default:- can be accessed anywhere

Modifier:- It is a modifier,It is a keyword, Behaviour of the method(user defined)
           1.static
           2.final
           3.synchronizes
           4.volatile
           5.transient
-> if static is removed or absent then it is non-static

Return type:- Used to return the data back to the method block
              2 types:- 1. void :- It is a keyword, It does not return any value back to the method block
                        2. datatype
->return type can be class(user defined) also can be in-built class.

user defined methods:- 
1. non parameterized:- 1.method without arguments and without return statement
                       ->syntax:- [Access modifier] [modifier] return type(void) method name()
                       {

                       }

                       2.method without arguments but with return statement
                       ->syntax:- [Access modifier] [modifier] return type(data type) method name()
                       {
                        return statement;
                       }

2. parameterized:- 1.method with arguments but without return statement
                   ->syntax:- [Access modifier] [modifier] return type(void) method name(datatype var/user definded class obj/Inbuilt class obj)
                   {
                        local variable->class obj(user/Inbuilt)
                   }

                   2.method with arguments and return statement
                   ->syntax:- [Access modifier] [modifier] return type(data type) method name(datatype var/user definded class obj/Inbuilt class obj)
                   {
                        local variable->class obj(user/Inbuilt)
                        return statement;
                   }

->method chaining:- Method chaining is a programming technique in Java where one objects calls other object and so on, and the one method should be called atleast 1 time in main method.
eg:- public class method1 {
    public static void main(String[] args) {
        System.out.println("Start");  //prints start
        demo1();   // go to demo1 method
        System.out.println("End"); //prints End
    }

    public static void demo1(){
        System.out.println("Demo1() method"); // prints Demo1() method
        demo2(); // go to demo2 method
        // after coming from demo2 method go back to main method
    }

    public static void demo2(){
        System.out.println("Demo2() method"); // prints Demo2() method, go back to demo1() method
        
    }
}

-> We cannot call void methods in parameterized method.


