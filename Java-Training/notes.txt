Workflow of java code => Code -> compiler -> byte code -> JVM(JIT + Interpreter) -> binary code
Java is a high level language which is easily readable, understandable and instructable by programmer.
It is platform independent, because in java source code is converted into byte code which is easily executable in any platform which has JVM.
JVM - JVM stands for java virtual machine. It does not exists physically. It is used to convert byte code into binary code. It consists of JIT and Interpreter.
JRE - JRE stands for java runtime environment. It exists physically. It is used to provide environment to run the java program.
JDK - JDK stands for java development kit. It exists physically. It provides an environment to run as well as to develop a java program.

# Printing statements
System.out.print(); -> After printing the data the cursor is shifted to next position in same line.
System.out.println(); -> After printing the data the cursor is shifted to next position in new line.

# TOKENS:- The smallest part of java program
Types:-
1. Keywords:- Words with predefined meaning. (50+ keywords)
              It is also known as compiler aware words. 
              They should always be in lowercase. 
              In java we have 50+ keywords(eg:- class, public, static, void).

2. Identifier:- The name given by programmer. (cannot use keyword or character space, should not start with number, special characters are not allowed except _ and $) (eg:- class name, variable name, method names, package name)

3. Literals:- The value or data given by programmer.
Types:-
1.Number:- Integer and Floating number.

2.Character:- It is used to represent a single data. 
              It is enclosed inside single quotes.
              Length of character literal is one. 
              It can have lowercase, uppercase, single digits, all type of special characters.

3.String: - It is used to represent group of characters. 
            It is enclosed inside double quotes. 
            The length of string literal can br anything

4.Boolean - It gives us only 2 values, either true or false.

4.Separators:- To Separate java members.
Types:- 
{} - to separate block
() - separate equations, method declaration, write conditions
; - end of statement
, - separate variables
. - separate reference

5.Operators:- Symbol which represents particular operations
Types:-
1.Uniary:- 1.increment operator -> 1. Pre-increment 2. Post-increment
           2.decrement operator -> 1. Pre-decrement 2. Post-decrement
           3.logical not operator

2.Binary:- 1.Arithmetic operator
           2.Relational operator
           3.Logical AND operator
           4.Logical OR operator

3.Ternary:- Conditional operator

# DataTypes:- What type of data we are storing inside any variable
1. Primitive:- Inbuilt datatype, have fixed size. (byte,short,int,long | float,double | char | boolean)
2. Non-Primitive:- Does not have fixed size. (string,classname,arrays)

# Types of variables:-
1. Based on datatype:- 1. Primitive
                       2. Non- Primitive

2. Based on scope:- 1. Local variable(declared in local block or method block)
                    2. Global variable(declared in class block or global)

static variable:- A varivable which is declared inside class or global area prefixed with static keyword.
non static variable: - A varible which is declared inside class or global area without static keyword.

local varibable:- A variable which is declared inside local block. 
                  We cannot use local variables without initialisation. 
                  Local variables are not assigned with default values.
                  We cannot create two local variables with same name.
                  local varible can be used only inside same local block.

Gloal variables: - We can use global variables inside global as well as local area.

pre-increment operator steps:- 1.Increase the value by 1.
                               2.Update the incremented value in same variable.
                               3.If any operation is going on, will have to use the incremented value.

# Question
Q. Difference b/w primitive and non primitive data types?
-> Primitive data type has fixed size, they are pre defined. 
-> Non-primitive does not have fixed value and they are user defined.


Q. Difference b/w local and global variable?
-> local varibables can only be declared in local area. It cannot be used without initialisation. It can only be used in local area. We cannot create two local variables with same name.
-> Global varivables are declared in global area. It can be used inside gloabal as well as local area.


Q. Difference b/w compiler and Interpreter?
-> Compiler translates the high level code into machine code(byte code) before execution.
-> Interpreter translates and executes the code line by line at runtime.

Q. Difference b/w platform independent and platform dependent?
-> Platform-dependent software runs only on specific operating systems/hardware (like C/C++ compiled to native code)
-> Platform-independent software runs anywhere via an intermediary like a Virtual Machine (JVM for Java), allowing "write once, run anywhere" for Java, Python, etc.

Q. How does object oriented nature of java helps in software development?
-> Object-oriented programming (OOP) in Java accelerates software development by promoting code reusability through inheritance and composition, allowing new classes to inherit features from existing ones.

Q. Why java is considered simple language compared to c or c++?
-> Java is considered simpler than C or C++ due to a variety of design choices that reduce complexity for the programmer, such as automatic memory management (garbage collection), fewer language features, and a stronger emphasis on object-oriented programming.

Q. How does java provide security at runtime?
-> Java provides security at runtime through a multi-layered architecture centered around the Java Virtual Machine (JVM), which includes bytecode verification, a security sandbox, and extensive security APIs.

Q. What makes java as robust language?
-> Java is considered a robust language due to features that emphasize early error detection, effective error management, and reliable memory handling.

Q. How does java acheive high performance?
-> Through the Just-In-Time (JIT) compilation process and the sophisticated optimizations within the Java Virtual Machine (JVM).

Q. What do you mean by portability in java?
-> In Java, portability refers to the ability to compile a program's source code into a machine-independent bytecode on one machine and then run that same bytecode on any other device or operating system that has a compatible Java Virtual Machine (JVM) installed, without needing to recompile the code.

# Arithmetic Operators
(Addititon)
byte + byte -> CTE
short + short -> CTE
int + int -> success
long + long -> success
float + float -> success
double + double -> success
char + char -> CTE
string + string -> concat

# Typecasting
1. Primitive (Not Recommended)
    Types:- 1.Widening(Implicitly done by the compiler);
            2.Narrowing(Explicit);

2. Non - Primitive (Highly Recommended)

# Widening(implicit)
byte < short OR char < int < long < float < double (float is greater than long)
value to char is not possible, but char to value is possible

# Narrowing(Explicit)
double > float > long > int > short OR char > byte 

eg:- int i = 150;
     byte b = (byte) i;  '(range of byte is  -128 to 127 means total 256)
     byte value = int value âˆ’ 256  (if int > 127)


# Scanner class
steps:- 1. import java.util.Scanner;
        2. Declare Scanner class object (We can declare it in class block as well as method block)

        Scanner obj_ref_name = new Scanner(System.in)

-> If you are taking int input and then string input(obj.nextLine()) you have to create a dummy. Also when we use next() and then nextLine() we have to create a dummy;
e.g:- 1. a = obj.nextInt();
         obj.nextLine();
         b = obj.nextLine();  //group of words

      2. a = obj.next();   //single word
         obj.nextLine();
         b = obj.nextLine();

-> To stop resource leak we have to close the object with obj.close().